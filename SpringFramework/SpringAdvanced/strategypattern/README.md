### 템플릿 메서드 패턴의 단점 
1. 자식 클래스가 부모 클래스(템플릿)를 상속받기 때문에, 자식 클래스는 원하던 원치 않던 부모 클래스의 기능을 가져와야 한다. 설사, 그 기능을 이용하지 않는다고 하더라도. 
즉, 컴파일 시점에 강하게 결합되어 있기 때문에 의존도가 매우 높으며, 자식 클래스가 부모 클래스에 영향을 많이 받는다. 

2. 템플릿 메서드 패턴은 상속 구조를 사용함으로써, 별도의 클래스나 익명 내부 클래스를 만들어야 한다.

<br>
* 이러한 단점을 제거할수 있는 디자인 패턴이 바로 전략 패턴(<b>Strategy Pattern</b>)이다.

<br><br>

### 전략패턴의 장점및 단점
1. 전략패턴의 경우 템플릿 메서드 패턴과 다르게 상속을 받지 않아 의존도가 많이 낮아진다. (필요한 것만 구현할수도 있다)

#### 단점
1. Context(템플릿 문맥)과 Strategy (변경 부분)을 조립한 이후에는 전략을 변경하기가 번거롭다. 설사 Setter를 통해 변경할수 있다 하더라도 운영중에는 (Singleton) 동시성 이슈 등이 발생할수 있다. -> 차라리 Context를 하나 더 생성하는게 낫다

<br>

### 더 유연하게 전략 패턴을 사용할수 있는 방법은 없을까?

1. ContextV1Test에 보면 -> 선 조립 후 실행을 한다. 즉 패턴(템플릿)에 내가 구현해 놓은 전략(메소드)를 조립해 놓은 이후. 내가 사용할때 execute만 사용한다. Compile시점에 이미 구현체가 패턴 안에 embedded되어 있다 (조립되어 있다). 따라서 실행만할수 있고 따로 변경할수가 없다.
<br>

2. ContextV2Test에는 -> 패턴(템플릿)에 메소드관련 전략에 관련된 인터페이스를 그대로 넣어두고, 내가 필요에 따라 파라미터로 전략을 넣어서 사용할수 있다. 즉, 중간에 내가 전략을 바꿔 쓸수 있다. (이것이 좀 더 유연하고 우리 문제에는 적합하다)

* 1, 2번의 차이는 1번은 여러 전략을 사용하기 위해서는 이미 조립이 되어 있기때문에 문맥을 하나 더 만들어야 하는 수고로움이 존재한다. 하지만 2번의 경우 하나의 문맥에서 전략을 바꿔 낄수가 있다.

* 참고로 디자인 패턴은 모양보다는 의도가 중요하다.

<br>

### 전략패턴중 2번째 방법 - 전략을 필요에 따라 주입해서 사용하는 것을 콜백패턴 이라함.
1. 콜백(callback)이란? 
- 피상적으로 콜백또는 콜애프터 함수는 다른 코드의 인수로 넘겨주는 실행 가능한 코드를 의미한다. (넘겨 받은 코드는 즉시 실행할수도,나중에 실행할수도 있다)

- 좀 더 의미적으로는 call + back의 의미를 알아보면, 내가 넘겨준 함수(코드)가 call이 되는데 back에서 호출된다는 의미를 갖는다. 

- 예제 개념 mapping: ContextV2Test에서 ContextV2가 문맥에 Strategy(Callback-함수)를 넘겨준다. 즉, Clinet가 직접 실행하는 것이 아니라 ContextV2(Back에서) Strategy(call함수를) 호출한다. 

 이렇게 전략을 파라미터로 넘겨주는 것을 전략패턴을 "템플릿 콜백 패턴"이라 한다. (GOF 패턴은 X) 단지, 스프링 내부에서 이런 방식을 주로 사용하기 때문에, 스프링 안에서만 이렇게 부른다. 
 스프링에서 JdbcTemplate, RestTemplate 등 다 템플릿 콜백 패턴을 사용한다.

 ### 예고편
 1. 템플렛 콜백 패턴 또한, 처음 보다는 많이 개선되었지만, 변화에 따라 원본 코드를 수정해야한다는 한계점이 있다. (상대적으로 덜 하게 된 건 맞음). 이 부분에 대해 앞으로는 원본 코드를 손대지 않고 로그 추적기를 적용할수 있는 방법을 알아볼 것이다. (프록시 개념 먼저 이해해야 한다.)